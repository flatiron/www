<!DOCTYPE html>
<html>
    <head>
        <title>Flatiron, A framework for Node.js</title>
        <meta charset="utf-8">
        <link rel="stylesheet" href="css/index.css">
        <link rel="stylesheet" href="css/app.css">
    </head>
    <body>

      <div id="header">
        <div id="headercontent">

          <div class="container" id="headover">
            <div class="row">
              <div class="panel" id="feature">
                <div class="center">
                  <img src="img/flatiron.png">
                  <br/>
                  <br/>
                    <b>flatiron</b> is an adaptable framework for building modern web applications. It was built from the ground up for use with <b>Javascript</b> and <b>Node.js</b>.
                  <br/>
                  <br/>
                  
                </div>
              </div>
            </div>
          </div>

          <div id="building"></div>

        </div>
      </div>

      <div id="toc" class="center">
        <div id="toc-content">
          <div class="button-group">
            <a href="#home" class="button icon home">Home</a>
            <a href="#routing" class="button">Routing</a>
            <a href="#templating" class="button">Templating</a>
            <a href="#data" class="button">Data Management</a>
            <a href="#middleware" class="button">Middleware</a>
            <a href="#plugins" class="button">Plugins</a>
            <a href="#logging" class="button">Logging</a>
            <!-- a href="#more" class="button icon add">More</a -->
          </div>
          <div class="button-group">
            <a href="http://www.github.com/flatiron" class="button icon fork">Fork on Github</a>
            <!--<a href="https://twitter.com/share" class="twitter-share-button button icon like" data-via="flatironjs" data-size="small" data-hashtags="nodejs">Mention on Twitter</a>
            <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script> -->
          </div>
        </div>
      </div>

      



      <div id="movable">
        <div class="container" id="main">

          <div class="row">

            <div class="span-one-third">
              <div class="panel">
                <h3>What's included?</h3>
                <br/>
                <a href="#routing">URL Routing</a><br/>
                A simple tool for <b>directing traffic</b> based on URLs that are recieved both on the browser and server.
                <br/>
                <br/>
                <a href="#templating">Templating</a><br/>
                An unobtrusive templating tool that is fast, <b>DSL free</b> and simple to use.
                <br/>
                <br/>
                <a href="#data">Data Management</a><br/>
                A storage agnostic resource-oriented object to document mapper for building <b>data models</b> with validation and sanitization.
                <br/>
                <br/>
                <a href="#middleware">Middleware</a><br/>
                A Modern hybrid buffered/streaming middleware kernel backwards compatible with connect.
                <br/>
                <br/>
                <a href="#plugins">Plugins</a><br/>
                A plugin manager that provides lightweight application extensibility and composition with a twist of feature reflection.
                <br/>
                <br/>
                <a href="#logging">Logging</a><br/>
                A multi-transport async logging library for node.js with plugins for many commonly targeted stores.
                <br/>
                <br/>

                <h3>There's more!</h3>
                <br/>
                Flatiron has many more repositories of useful tools! Simply explore the github repository for more details.
                Also, all tools are licensed under the MIT or Apache 2.0 License.
                <br/><br/>
              </div>

              
              <br/><br/>

              <div class="panel">
                  <h3>Who's responsible?</h3>
                  <br/>
                  <b>flatiron</b> is maintained by an open source community as well it has sponsorship from <b>nodejitsu</b>
                <div class="center">
                  <br/>
                  <img src="img/nodejitsu.png"/>

                  <br/>
                  <br/>

                </div>
                  You can sponsor <b>flatiron</b> by contacting <b>nodejitsu</b>. You can help promote it by clicking on the
                  tweet button. You can contribute to it by clicking on the fork button.
                  <br/>
                  <br/>

                <br/><br/>

              </div>

            </div>
            <div class="span-two-thirds">

              <h2 id="Philosophy">Philosophy</h2>
              <p>
              No one agrees on frameworks. It's difficult to get consensus on how much or how little a framework should do. Flatiron's approach is to package simple to use yet full featured components and let developers subtract or add what they want.</p>

              <h2 id="Motivation">Motivation</h2>
              <p>
              Build a collection of decoupled, unobtrusive tools that can operate as well in unison as they do independently. Promote code organization and sustainability by clearly separating development concerns.
              </p>

              <div class="h2-container first">
                <h2 class="green">Getting started with <span class="name">Flatiron</span></h2>
                <a href="http://github.com/flatiron/flatiron" class="button icon tag">Full project on Github</a>
              </div>
              <p>
              Since flatiron consists of largely a components, it's simple to start using.
              </p>

              <h3>Intallation</h3>
              <p>You'll need both Node.JS and NPM installed. (NPM is included by default with Node.JS, starting with version 0.6.3). You can download Node.js binary installers for MacOS and Windows <a href="http://nodejs.org/#download">here</a>.</p>
              
              <p>Flatiron comes with a commandline tool that can generate several application <b>boilerplates</b>.</p>
              <div class="panel">
                <p class="bash">$ [sudo] npm install flatiron -g</p>
              </div>
              <p>If everything works as expected, you'll now have a new command line tool called <code>flatiron</code>. To create a new project, go to an existing folder and run:</p>
              <div class="panel">
                <p class="bash">$ flatiron create &lt;app-name&gt; &lt;type&gt;</p>
              </div>
              
              <p>You can also simply include flatiron in your package.json and install locally with npm.</p>

              <div class="panel">
<pre class="syntax">
  {
    "name": "your-application",
    "dependencies": {
      "flatiron": "*"
    }
  }
</pre>
              </div>
              
              Installing your dependencies with <code>npm</code> will install flatiron and all nested dependencies:
              <br/><br/>
              <div class="panel">
                <p class="bash">$ cd /path/to/your/app <br/>
                  $ npm install</p>
              </div>
              

              <a id="routing">&nbsp;</a>

              <div class="h2-container">
                <h2 class="green">URL Routing with <span class="name">Director</span></h2>
                <a href="http://github.com/flatiron/director" class="button icon tag">Full project on Github</a>
              </div>

              <h3>What problem does it solve?</h3>
              <p>Director is a URL router. It works in a browser for single page apps <b>and</b> in Node.js. It's not a plugin for another framework. It's not dependent on anything. It's a modern router that was designed from the ground up with javascript.</p>

              <h3>Integration with Flatiron</h3>
              A Director based router is automatically attached to your application when using <code>flatiron.plugins.http</code> or <code>flatiron.plugins.cli</code>
              <br/><br/>
              
              <h4>CLI application</h4>
              <div class="panel">
<pre class="syntax">
  var flatiron = require('flatiron'),
       app = flatiron.app;
  
  app.use(flatiron.plugins.cli, {
    // CLI options
  });
  
  //
  // app.router is now available. app.cmd is also available
  // as a shortcut for creating routes
  //
  app.cmd('version', function () {
    console.log('flatiron ' + flatiron.version);
  });
</pre>
              </div>
              
              <h4>HTTP application</h4>
              <div class="panel">
<pre class="syntax">
  var flatiron = require('flatiron'),
      app = flatiron.app;
  
  app.use(flatiron.plugins.http, {
    // HTTP options
  });
  
  //
  // app.router is now available. app[HTTP-VERB] is also available
  // as a shortcut for creating routes
  //
  app.router.get('/version', function () {
    this.res.writeHead(200, { 'Content-Type': 'text/plain' })
    this.res.end('flatiron ' + flatiron.version);
  });
  
  app.start(8080);
</pre>
              </div>

              <h3>How does it work?</h3>
              <p>On the client, it uses part of the URL to figure out what functions should execute, which usually has some effect on the way the page is presented.</p>

              <div class="panel">
<pre class="syntax"> var routes = {
  '/authors': {
    on: showAuthor,
    '/books': { on: [showCover, showDescription] },
    '/bios': { on: [showPicture, showBiography] }
  }
};

var router = Router(routes);</pre>
              </div>

              <p>On the server, it helps figure out what to do when a URL is requested from the server.</p>

              <div class="panel">
<pre class="syntax">
//
// require the native http module, as well as director.
//
var http = require('http'),
    director = require('director');

//
// for the sake of example, lets actually define one of the
// functions that might be called from in a routing table.
//
function showAuthor() {
  this.res.writeHead(200, { 'Content-Type': 'text/plain' })
  this.res.end('Carl Sagan');
}

var routes = {
  '/authors': {
    on: showAuthor,
    '/books': { on: [showCover, showDescription] },
    '/bios': { on: [showPicture, showBiography] }
  }
};

//
// define a routing table.
//
var router = new director.http.Router(routes);

//
// setup a server and when there is a request, dispatch the
// route that was requestd in the request object.
//
var server = http.createServer(function (req, res) {
  router.dispatch(req, res, function (err) {
    if (err) {
      res.writeHead(404);
      res.end();
    }
  });
});

//
// You can also do ad-hoc routing, similar to `journey` or `express`.
// This can be done with a string or a regexp.
//
router.get('/bonjour', helloWorld);
router.get(/hola/, helloWorld);

//
// set the server to listen on port `8080`.
//
server.listen(8080);
</pre>
              </div>

              A route table is as simple as an object literal. A potentially nested set of key/value pairs. The keys in the object literal represent each potential part of the URL. The values in the object literal contain references to the functions that should be associated with them.

              <a id="templating">&nbsp;</a>

              <div class="h2-container">
                <h2 class="green">Templating with <span class="name">Plates</span></h2>
                <a href="http://github.com/flatiron/plates" class="button icon tag">Full project on Github</a>
              </div>

              <p>Plates (short for templates) binds data to markup. It's DSL free! Which means that there is NO special syntax. It's Javascript, Markup and JSON. It works in the browser and in node.js!</p>

              <h3>What problem does it solve?</h3>
              <br/>
              <ul>
                <li>DSLs (Domain Specific Languages) such as &lt;%=foo%&gt; or {{foo}} reduce portability.</li>
                <li>DOM templating is SLOW.</li>
                <li>Promote the separation of concerns principle by decoupling decision making from presentation.</li>
                <li>Make both the code and markup more readable and maintainable by a wider audience.</li>
              </ul>

              <h3>Integration with Flatiron</h3>
              No special integration with <code>flatiron</code> is provided, you can simply use plates by requiring it.<br/><br/>
              
              <div class="panel">
<pre class="syntax">
  var plates = require('plates');
</pre>
              </div>

              <h3>How does it work?</h3>
              <p>
              By default, plates will try to match the data-key in the data to an ID in the tag, since both should be unique.
              </p>
             
             <div class="panel">
<pre class="syntax">
var plates = require('plates');

var html = '&lt;div id="test"&gt;Old Value&lt;/div&gt;';
var data = { "test": "New Value" };

var output = plates.bind(html, data); 
</pre>
</div>
              <p>
              A common use case is to apply the new value to each tag's body based on the class attribute.
              </p>
             <div class="panel">
<pre class="syntax">
var html = '&lt;span class="name"&gt;User&lt;/span&gt;...&lt;span class="name"&gt;User&lt;/span&gt;';

var data = { "username": "John Smith" };
var map = plates.Map();

map.class('name').to('username');

console.log(plates.bind(html, data, map));
</pre>
</div>
              <p>
              Another common case is to want to replace the value of an attribute if it is a match.
              </p>
             <div class="panel">
<pre class="syntax">
var html = '&lt;a href="/"&gt;&lt;/a&gt;';

var data = { "newurl": "http://www.nodejitsu.com" };
var map = plates.Map();

map.where('href').is('/').insert('newurl');

console.log(plates.bind(html, data, map));
</pre>
</div>
              <p>
              In even more complex cases, an arbitrary attribute an be specified, if a value is matched, a specific value can be used and then used as anther attribute's value.
              </p>
             <div class="panel">
<pre class="syntax">
var html = '&lt;a href="/"&gt;&lt;/a&gt;';

var data = { "imageurl": "http://www.nodejitsu.com" };
var map = plates.Map();

map.where('data-foo').is('bar').use('imageurl').as('src');

console.log(plates.bind(html, data, map));
</pre>
</div>

             <a id="data">&nbsp;</a>

              <div class="h2-container">
                <h2 class="green">Data Management with <span class="name">Resourceful</span></h2>
                <a href="http://github.com/flatiron/resourceful" class="button icon tag">Full project on Github</a>
              </div>
              <p>Resourceful provides an engine agnostic interface to JSON document stores, as well as a convienient and flexible caching layer.
              </p>

              <h3>What problem does it solve?</h3>
              <p>How often have you found yourself writing Model code in your application? Pretty often? Good! Unlike other "Object-Document Mappers" `resourceful` tries to only focus on two things:</p>

              <ul>
                <li>A simple API for defining custom Model prototypes with validation. No special sugar is required to instantiate prototypes defined by resourceful.</li>

                <li>Define an extensibility model for databases to provide CRUD functionality to Models along with custom query, filtering or updating specific to that specific implementation (Mongo, CouchDB, Redis, etc).</li>
              </ul>
              
              <h3>Integration with Flatiron</h3>
              No special integration with <code>flatiron</code> is provided, you can simply use resourceful by requiring it.<br/><br/>
              
              <div class="panel">
<pre class="syntax">
  var resourceful = require('resourceful');
</pre>
              </div>

              <h3>How does it work?</h3>
              Resources can be defined using <code>resourceful.define(name, factory)</code>. Once a resource prototype is created it can be treated as a normal Javascript prototype.<br/><br/>
              
              <br/>
             <div class="panel">
<pre class="syntax">
var Creature = resourceful.define('creature');

Creature.property('diet'); // Defaults to String
Creature.property('vertebrate', Boolean);
Creature.property('belly', Array);

Creature.prototype.feed = function (food) {
  this.belly.push(food);
};

var wolf = new Creature({
  diet:      'carnivor',
  vertebrate: true
});

wolf.feed('squirrel');
console.dir(wolf.belly);
// ['squirrel']
</pre>
</div>


             <a id="middleware">&nbsp;</a>

              <div class="h2-container">
                <h2 class="green">Middleware with <span class="name">Union</span></h2>
                <a href="http://github.com/flatiron/union" class="button icon tag">Full project on Github</a>
              </div>

              <p>Union is a minimalist middleware framework for node.js. It's minimalist, but extensible. Union's request handling is compatible with `connect`, meaning that all existing `connect-middlewares` should work out of the box with union.
              </p>

              <h3>What problem does it solve?</h3>
              <p>It provides an easy way to interact with requests before and after they are processed. But it's primary value add is that it's a hybrid buffered, streaming middleware kernel that isn't coupled with any other software.</p>
              
              <h3>Integration with Flatiron</h3>
              By using <code>flatiron.plugins.http</code> you can configure and control a <code>union</code> server. The middleware used by <code>union</code> are compatible with express and connect.<br/><br/>
              
              <div class="panel">
<pre class="syntax">
  var flatiron = require('flatiron'),
      app = flatiron.app;
  
  app.use(flatiron.plugins.http, {
    //
    // List of middleware to use before dispatching 
    // to app.router
    //
    before: [],
    //
    // List of Streams to execute on the response pipeline 
    //
    after: []
  });
  
  //
  // Both app.listen(port, [host,] callback) and 
  // app.start(port, [host,] callback) are now attached 
  // to your application. app.start() will automatically 
  // call app.listen() after calling app.init().
  //
  app.listen(8000, function () {
    console.log('Application is now started on port 8000');
  });
</pre>
              </div>
              
              <h3>How does it work?</h3>
              <br/>
             <div class="panel">
<pre class="syntax">
//
// for the sake of this example, lets define a function to represent our
// middleware. Your middleware would likely be a more complex module.
//
function middleware1(req, res) {
  if(~req.url.indexOf('foo')) {
    return false;
  }
}

var server = union.createServer({
  before: [
    middleware1
  ]
});

router.get(/foo/, function () {
  this.res.writeHead(200, { 'Content-Type': 'text/plain' });
  this.res.end('never sent\n');
});
</pre>
</div>

             <a id="plugins">&nbsp;</a>

              <div class="h2-container">
                <h2 class="green">Plugins with <span class="name">Broadway</span></h2>
                <a href="http://github.com/flatiron/broadway" class="button icon tag">Full project on Github</a>
              </div>

              <p>
              Broadway exposes a simple "plugin" API which allows the application developer to extend the top-level application object easily.
              </p>

              <h3>What problem does it solve?</h3>
              <p>This plugin model translates well between the browser and the server because developers can write different plugins to suite the needs of the different environments. Broadway includes several plugins by default which can be overridden if you don't agree with the particular module or library choice we've made.</p>

              <h3>Integration with Flatiron</h3>
              Each <code>flatiron.App</code> instance inherits from <code>broadway.App</code>. This means that you can write your own plugins to extend your application as you see fit.<br/><br/>

              <div class="panel">
<pre class="syntax">
  var flatiron = require('flatiron'),
      app = flatiron.app;

  var customPlugin = {
    name: 'custom-plugin',
    attach: function (options) {
      //
      // Extend the application
      //
      app.yourCustomMethod = function () {
        
      };
    },
    init: function (done) {
      //
      // Initialize anything your plugin needs,
      // asynchronously if necessary, then call done().
      //
      done();
    }
  };
  
  app.use(customPlugin);
</pre>
              </div>

              <h3>How does it work?</h3>
              <p>Each plugin in <code>broadway</code> interacts with an application instance through four properties illustrated in the code sample below:</p>
              
             <div class="panel">
<pre class="syntax">
var plugin = {
  "name": "example-plugin", // Plugin's name

  "attach": function attach(options) {
    // Called with plugin options once plugin attached to application
    // `this` - is a reference to application
  },

  "detach": function detach() {
    // Called when plugin detached from application
    // (Only if plugin with same name was attached)
    // `this` - is a reference to application
  }

  "init": function init(callback) {
    // Called on application initialization
    // App#init(callback) called once every plugin will call `callback`
    // `this` - is a reference to application
  }
};
</pre>
</div>

             <a id="logging">&nbsp;</a>

              <div class="h2-container">
                <h2 class="green">Logging with <span class="name">Winston</span></h2>
                <a href="http://github.com/flatiron/winston" class="button icon tag">Full project on Github</a>
              </div>

              <p>A multi-transport async logging library.</p>

              <h3>What problem does it solve?</h3>
              <p>Winston is designed to be a simple and universal logging library with support for multiple transports. A transport is essentially a storage device for your logs. Each instance of a winston logger can have multiple transports configured at different levels. For example, one may want error logs to be stored in a persistent remote location (like a database), but all logs output to the console or a local file.</p>

              <p>There also seemed to be a lot of logging libraries out there that coupled their implementation of logging (i.e. how the logs are stored / indexed) to the API that they exposed to the programmer. This library aims to decouple those parts of the process to make it more flexible and extensible.</p>
              
              <h3>Integration with Flatiron</h3>
              Using <code>flatiron.plugins.log</code> will automatically extend your application with logging capabilities from <code>winston</code>. This plugin is included by default in both CLI and HTTP flatiron apps.<br/><br/>
              
              <div class="panel">
<pre class="syntax">
  var flatiron = require('flatiron'),
      app = flatiron.app;

  app.log.info('Logging to my flatiron application', {
    with: 'custom metadata'
  });
</pre>
              </div>

              <h3>How does it work?</h3>
              <br/>
             <div class="panel">
<pre class="syntax">
var winston = require('winston');

winston.log('info', 'Hello distributed log files!');
winston.info('Hello again distributed logs');
</pre>
</div>

              <p>By default, only the Console transport is set on the default logger. You can add or remove transports via the add() and remove() methods:</p>

             <div class="panel">
<pre class="syntax">
winston.add(winston.transports.File, { filename: 'somefile.log' });
winston.remove(winston.transports.Console);
</pre>
             </div>


            </div>
          </div>
        </div>


        <script type="text/javascript">

          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-24971485-5']);
          _gaq.push(['_setDomainName', 'none']);
          _gaq.push(['_setAllowLinker', true]);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();

        </script>

        <!--[if lt IE 7 ]>
          <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
          <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
        <![endif]-->
      </div>

      <script type="text/javascript" src="js/jquery-1.7.1.min.js"></script>
      <script type="text/javascript" src="js/index.js"></script>
      <script type="text/javascript" src="js/hi.js"></script>

    </body>
</html>




